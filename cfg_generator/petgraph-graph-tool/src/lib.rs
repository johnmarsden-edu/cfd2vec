//! [![docs.rs badge](https://docs.rs/petgraph-graphml/badge.svg)](https://docs.rs/petgraph-graphml/)
//! [![crates.io badge](https://img.shields.io/crates/v/petgraph-graphml.svg)](https://crates.io/crates/petgraph-graphml/)
//! [![Rust CI](https://github.com/jonasbb/petgraph-graphml/workflows/Rust%20CI/badge.svg)](https://github.com/jonasbb/petgraph-graphml)
//! [![codecov](https://codecov.io/gh/jonasbb/petgraph-graphml/branch/master/graph/badge.svg)](https://codecov.io/gh/jonasbb/petgraph-graphml)
//!
//! ---
//!
//! This crate extends [petgraph][] with [graph-tool][graph-tool-website] output support.
//!
//! This crate exports a single type [`GraphTool`] which combines a build-pattern for configuration and provides creating strings ([`GraphTool::to_string`]) and writing to writers ([`GraphTool::to_writer`]).
//!
//! # Usage
//!
//! Add this to your `Cargo.toml`:
//!
//! ```toml
//! [dependencies]
//! petgraph-graph-tool = "0.0.1"
//! ```
//!
//! [`GraphTool`]: https://docs.rs/petgraph-graph-tool/*/petgraph_graphml/struct.GraphMl.html
//! [`GraphTool::to_string`]: https://docs.rs/petgraph-graph-tool/*/petgraph_graph-tool/struct.GraphTool.html#method.to_string
//! [`GraphTool::to_writer`]: https://docs.rs/petgraph-graph-tool/*/petgraph_graph-tool/struct.GraphTool.html#method.to_writer
//! [graphmlwebsite]: http://graphml.graphdrawing.org/
//! [petgraph]: https://docs.rs/petgraph/

#![deny(
    missing_debug_implementations,
    missing_copy_implementations,
    missing_docs,
    trivial_casts,
    trivial_numeric_casts,
    unused_extern_crates,
    unused_import_braces,
    unused_qualifications,
    variant_size_differences
)]
#![allow(unknown_lints, clippy::return_self_not_must_use)]
#![doc(html_root_url = "https://docs.rs/petgraph-graph-tool/0.0.1")]

/// This module is a sub-module containing all of the possible attribute types
/// supported by this printer.
pub mod attr_types;

use crate::attr_types::{GtString, GtTypes};
use petgraph::prelude::NodeIndex;
use petgraph::visit::{Data, EdgeRef, IntoNodeReferences};
use petgraph::{Direction, Graph};

use std::fmt::{self, Debug, Display, Formatter};
use std::io::{self, BufWriter, Write};
use std::iter::Chain;

// A type for new attributes
type ConvertWeightToGtType<W, T> = dyn for<'a> Fn(&'a W) -> T;

trait PropertyMap<W> {
    fn get_bytes(&self, it: &mut dyn Iterator<Item = &W>) -> Vec<u8>;
}

/// This is a GraphToolAttribute. It's how you can define new attributes that will be written
/// to the graph-tool binary file generated by this printer
pub struct GraphToolAttribute<W, T>
where
    T: GtTypes,
{
    attr_name: Vec<u8>,
    attr_name_len: [u8; 8],
    attr_producer: Box<ConvertWeightToGtType<W, T>>,
}

impl<W, T: GtTypes> Debug for GraphToolAttribute<W, T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_struct("GraphToolAttribute")
            .field(
                "attr_name",
                &String::from_utf8(self.attr_name.clone()).unwrap(),
            )
            .finish()
    }
}

impl<W, T: GtTypes> PropertyMap<W> for GraphToolAttribute<W, T> {
    fn get_bytes(&self, it: &mut dyn Iterator<Item = &W>) -> Vec<u8> {
        let result = self.get_name_bytes();
        result
            .chain(std::iter::once(self.get_type_byte()))
            .chain(it.flat_map(|w| self.get_attr_value_bytes(w)))
            .collect()
    }
}

impl<W, T: GtTypes> GraphToolAttribute<W, T> {
    /// Creates a new GraphToolAttribute with the name `attr_name` and a function passed in
    /// that produces a value that must implement the GtTypes trait.
    pub fn new(attr_name: &'static str, attr_producer: Box<ConvertWeightToGtType<W, T>>) -> Self {
        GraphToolAttribute {
            attr_name: attr_name.bytes().map(|b| b.to_le()).collect(),
            attr_name_len: (attr_name.len() as u64).to_le_bytes(),
            attr_producer,
        }
    }

    fn get_name_bytes(
        &self,
    ) -> Chain<impl Iterator<Item = u8> + '_, impl Iterator<Item = u8> + '_> {
        self.attr_name_len
            .iter()
            .copied()
            .chain(self.attr_name.clone())
    }

    fn get_type_byte(&self) -> u8 {
        T::get_type_byte()
    }

    fn get_attr_value_bytes(&self, weight: &W) -> impl Iterator<Item = u8> {
        let value = (self.attr_producer)(weight);

        if let Some(length) = value.get_length() {
            (length as u64).to_le_bytes().to_vec()
        } else {
            Vec::new()
        }
        .into_iter()
        .chain(value.get_value_bytes())
    }
}

/// A builder for the graph tool printer
pub struct GraphTool<'a, G>
where
    G: Data,
    Graph<G::NodeWeight, G::EdgeWeight>: From<G>,
{
    graph: Graph<G::NodeWeight, G::EdgeWeight>,
    edge_attributes: Vec<Box<dyn PropertyMap<G::EdgeWeight> + 'a>>,
    node_attributes: Vec<Box<dyn PropertyMap<G::NodeWeight> + 'a>>,
}

impl<'graph, G> GraphTool<'graph, G>
where
    G: Data,
    Graph<G::NodeWeight, G::EdgeWeight>: From<G>,
    G: 'graph,
    G::NodeWeight: 'graph,
    G::EdgeWeight: 'graph,
{
    /// Create a new graph-tool printer builder for the graph.
    pub fn new(graph: G) -> Self {
        Self {
            graph: graph.into(),
            edge_attributes: Vec::new(),
            node_attributes: Vec::new(),
        }
    }

    /// Export the edge weights to GraphTool.
    ///
    /// This uses the [`Display`] implementation of the edge weight type.
    /// The attribute name defaults to "weight".
    ///
    /// Once set this option cannot be disabled anymore.
    ///
    /// [`Display`]: Display
    pub fn add_display_edge_attribute(&mut self) -> &mut Self
    where
        G::EdgeWeight: Display,
    {
        self.add_edge_attribute::<GtString>(GraphToolAttribute::<G::EdgeWeight, GtString>::new(
            "weight",
            Box::new(|w| w.to_string().into()),
        ))
    }

    /// Export the edge weights to GraphML.
    ///
    /// This uses a custom conversion function.
    /// Each edge can be converted into an arbitray number of attributes.
    /// Each attribute is a key-value pair, represented as tuple.
    ///
    /// Once set this option cannot be disabled anymore.
    ///
    /// # Example
    ///
    /// A custom print function for the type `(String, u32)`.
    /// It will create two attributes "str attr" and "int attr" containing the string and integer part.
    ///
    /// ```
    /// # use petgraph::Graph;
    /// # use petgraph_graph_tool::attr_types::GtString;
    /// # use petgraph_graph_tool::GraphToolAttribute;
    /// # use petgraph_graphml::GraphMl;
    /// # fn make_graph() -> Graph<(), (String, u32)> {
    /// #     Graph::new()
    /// # }
    /// let graph = make_graph();
    /// let graphml = GraphMl::new(&graph).add_edge_attribute(GraphToolAttribute::<G::EdgeWeight, GtString>::new(
    ///             "str attr",
    ///             Box::new(|w| w.to_string().into()),
    ///         ));
    /// ```
    pub fn add_edge_attribute<A: GtTypes + 'static>(
        &mut self,
        edge_attr: GraphToolAttribute<<G as Data>::EdgeWeight, A>,
    ) -> &mut Self {
        let property_mapper: Box<dyn PropertyMap<G::EdgeWeight> + 'graph> = Box::new(edge_attr);
        self.edge_attributes.push(property_mapper);
        self
    }

    /// Export the node weights to GraphML.
    ///
    /// This uses the [`Display`] implementation of the node weight type.
    /// The attribute name defaults to "weight".
    ///
    /// Once set this option cannot be disabled anymore.
    ///
    /// [`Display`]: Display
    pub fn add_display_node_attribute(&mut self) -> &mut Self
    where
        G::NodeWeight: Display,
    {
        self.add_node_attribute::<GtString>(GraphToolAttribute::<G::NodeWeight, GtString>::new(
            "weight",
            Box::new(|w| w.to_string().into()),
        ))
    }

    /// This adds a custom
    ///
    /// Once set this option cannot be disabled anymore.
    ///
    /// # Example
    ///
    /// A custom print function for the type `(String, u32)`.
    /// It will create two attributes "str attr" and "int attr" containing the string and integer part.
    ///
    /// ```
    /// # use petgraph::Graph;
    /// # use petgraph_graph_tool::attr_types::GtString;
    /// # use petgraph_graph_tool::GraphToolAttribute;
    /// # use petgraph_graphml::GraphMl;
    /// # fn make_graph() -> Graph<(String, u32), ()> {
    /// #     Graph::new()
    /// # }
    /// let graph = make_graph();
    /// let graphml = GraphMl::new(&graph).add_node_attribute(GraphToolAttribute::<G::NodeWeight, GtString>::new(
    ///             "int attr",
    ///             Box::new(|w| {
    ///                 let &(_, i) = w;
    ///                 w.to_string().into()
    ///             }
    ///         )));
    /// ```
    pub fn add_node_attribute<A: GtTypes + 'static>(
        &mut self,
        node_attr: GraphToolAttribute<<G as Data>::NodeWeight, A>,
    ) -> &mut Self {
        let property_mapper: Box<dyn PropertyMap<G::NodeWeight>> = Box::new(node_attr);
        self.node_attributes.push(property_mapper);
        self
    }

    /// This will write the graph to a vector of bytes that will then be returned
    pub fn to_bytes(&self) -> io::Result<Vec<u8>> {
        let mut bytes = Vec::new();
        self.write_to(&mut bytes)?;
        Ok(bytes)
    }

    /// Write the GraphML file to the given writer.
    pub fn write_to<W>(&self, writer: W) -> io::Result<()>
    where
        W: Write,
    {
        let mut writer = BufWriter::new(writer);
        self.emit_gt(&mut writer)
    }

    fn emit_gt<W>(&self, writer: &mut BufWriter<W>) -> io::Result<()>
    where
        W: Write,
    {
        self.emit_graph(writer)?;
        Ok(())
    }

    /// This emits the graph to a buf writer in the gt file format
    ///
    /// The file format can be found here: https://graph-tool.skewed.de/static/doc/gt_format.html
    ///
    /// If the file format has updated to version 2 then look at version 1
    fn emit_graph<W>(&'graph self, writer: &mut BufWriter<W>) -> io::Result<()>
    where
        W: Write,
    {
        // The gt file format is a simple binary format designed to store graph-tool Graph instances
        // in a compact and fast manner, including all types of property maps supported by the
        // library. It serves as an alternative to the text-based graphml format for very large
        // graphs where I/O may become very time and space consuming.

        // The header begins with the magic string ⛾ gt in utf-8 encoding, totaling 6 bytes,
        // followed by the version number (currently 0x01) in a single byte, and a Boolean
        // (also a single byte) determining the endianness (0x00: little-endian, 0x01: big-endian):

        // The header of the graph-tool format starts with a magic string
        const MAGIC_STRING: &[u8] = "⛾ gt".as_bytes();
        writer.write_all(MAGIC_STRING)?;

        // Then we provide the version number for this format of the gt file format
        const VERSION_NUMBER: u8 = 0x01;
        writer.write_all(&[VERSION_NUMBER.to_le()])?;

        // Endianess is 0x00 for little-endian and 0x01 for big-endian. We default to
        // little-endian to simplify the complexity of implementation
        const ENDIANESS: u8 = 0x00;
        writer.write_all(&[ENDIANESS.to_le()])?;

        // This is followed by a comment string. Strings are stored by a length (8 bytes, uint64_t)
        // and the corresponding sequence of bytes, not null-terminated. The comment may be empty,
        // but graph-tool outputs a human readable summary of the file, which can be inspected with
        // tools like hexdump:

        // Next we write a comment string.
        let comment: GtString = "graph-tool binary file version 1 (https://graph-tool.skewed.de/static/doc/gt_format.html) generated by petgraph-graph-tool".to_string().into();

        writer.write_all(
            &comment
                .get_length()
                .expect("This can't be None as it is a string")
                .to_le_bytes(),
        )?;
        writer.write_all(&comment.get_value_bytes())?;

        // The adjacency list now follows, beginning with a Boolean byte specifying whether or not
        // the graph is directed (0x00: undirected, 0x01: directed), and 8 bytes (uint64_t)
        // containing the number of nodes, N.

        // Write the graph type byte
        writer.write_all(&[if self.graph.is_directed() { 0x01 } else { 0x00 }])?;

        // Write the number of nodes
        writer.write_all(&(self.graph.node_count() as u64).to_le_bytes())?;

        // We need to only output the minimum number of bytes to represent the neighbor index.
        let mapper = {
            let len = self.graph.node_count();
            if u8::try_from(len).is_ok() {
                |n: &NodeIndex| {
                    u8::try_from(n.index())
                        .expect("This must be true by the len requirement")
                        .to_le_bytes()
                        .to_vec()
                }
            } else if u16::try_from(len).is_ok() {
                |n: &NodeIndex| {
                    u16::try_from(n.index())
                        .expect("This must be true by the len requirement")
                        .to_le_bytes()
                        .to_vec()
                }
            } else if u32::try_from(len).is_ok() {
                |n: &NodeIndex| {
                    u32::try_from(n.index())
                        .expect("This must be true by the len requirement")
                        .to_le_bytes()
                        .to_vec()
                }
            } else if u64::try_from(len).is_ok() {
                |n: &NodeIndex| {
                    u64::try_from(n.index())
                        .expect("This must be true by the len requirement")
                        .to_le_bytes()
                        .to_vec()
                }
            } else {
                unreachable!("If we ever reach this then we are handling a case we don't support")
            }
        };

        // It is followed by the list of out-neighbors of all N
        // nodes in sequence. The sequence itself determines implicitly the index of the nodes, in
        // the range from 0 to N-1. The list of out-neighbors of a given node is composed of a
        // length (8 bytes, uint64_t) and a sequence of node indexes with this length. The number
        // of bytes d used to encode the node indexes in this list is determined by the value of N,
        // and will be the smallest value of the set {1, 2, 4, 8} (i.e. {uint8_t, uint16_t,
        // uint32_t, uint64_t}, respectively) which is sufficient to accommodate all N nodes. For
        // undirected graphs, here it is important that each edge appears only once, i.e. if node u
        // appears in the list of neighbors of v, then v should not appear in the list of u again,
        // otherwise it will be considered as a different (parallel) edge. In this way, the total
        // number of bytes used for the adjacency is 1 + 8 + N * 8 + E * d with E being the number
        // of edges:

        // Write out the out neighbors of all nodes
        for node_index in self.graph.node_indices() {
            let neighbors: Vec<NodeIndex> = self
                .graph
                .neighbors_directed(node_index, Direction::Outgoing)
                .filter(|n| self.graph.is_directed() || n.index() >= node_index.index())
                .collect();

            writer.write_all(
                &u64::try_from(neighbors.len())
                    .unwrap_or_else(|_| {
                        panic!("You have too many neighbors for {}", node_index.index())
                    })
                    .to_le_bytes(),
            )?;
            let neighbor_bytes: Vec<u8> = neighbors.iter().flat_map(mapper).collect();
            writer.write_all(neighbor_bytes.as_slice())?;
        }

        // The adjacency is followed by a list of property maps. The list begins with a total
        // number of property maps (8 bytes, uint64_t), and then the individual records. Each
        // property map begins with a key type (1 byte, uint8_t) specifying whether it is a graph
        // (0x00), a vertex (0x01) or an edge (0x02) property map, followed by a string (8 byte
        // length + length bytes) containing the name of the property map. This is then followed by
        // a byte (uint8_t) specifying the value type index, from the following table:

        // See table on website

        // The values of the property map follow in the order of the vertex indexes (for vertex
        // properties) or in the same order in which the edges appear in the preceding adjacency
        // list (for edge properties). For graph properties only one value follows. Strings and
        // vectors are encoded with a length prefix of 8 bytes (uint64_t) followed by a sequence of
        // that size with the appropriate element size. The elements of vector<string> are encoded
        // as pairs of (8 byte length, bytes) as usual. Values of type python::object are encoded
        // just as strings, with the string content encoded or decoded via pickle.

        writer.write_all(
            &u64::try_from(self.node_attributes.len() + self.edge_attributes.len())
                .expect("The length of the number of property maps must fit in a u64")
                .to_le_bytes(),
        )?;

        for node_attribute_mapper in self.node_attributes.iter() {
            writer.write_all(&[0x01])?;

            let mut nodes = Vec::new();
            for (_, node_ref) in self.graph.node_references() {
                nodes.push(node_ref);
            }

            let it: &mut dyn Iterator<Item = &G::NodeWeight> = &mut nodes.into_iter();
            writer.write_all(node_attribute_mapper.get_bytes(it).as_slice())?;
        }

        for edge_attribute_mapper in self.edge_attributes.iter() {
            // Because of the way that edges are represented in the gt file format, we need to
            // iterate through the nodes in order to find the edges in the correct order for
            // gt. We also do not want duplicate edges so we need to ensure we filter out any
            // edges that we have already seen. Since we are doing this in order, we can
            // trivially say that we have already seen a node if it's index is less than our
            // current node.
            let mut edges = Vec::new();
            if self.graph.is_directed() {
                for node_index in self.graph.node_indices() {
                    for edge in self.graph.edges_directed(node_index, Direction::Outgoing) {
                        edges.push(edge.weight());
                    }
                }
            } else {
                for node_index in self.graph.node_indices() {
                    for edge in self.graph.edges_directed(node_index, Direction::Outgoing) {
                        if edge.target().index() >= node_index.index() {
                            edges.push(edge.weight());
                        }
                    }
                }
            };
            let it: &mut dyn Iterator<Item = &G::EdgeWeight> = &mut edges.into_iter();
            writer.write_all(&[0x02])?;
            writer.write_all(edge_attribute_mapper.get_bytes(it).as_slice())?;
        }

        Ok(())
    }
}

impl<'a, G> Debug for GraphTool<'a, G>
where
    G: Data,
    Graph<G::NodeWeight, G::EdgeWeight>: From<G>,
    G::NodeWeight: Debug,
    G::EdgeWeight: Debug,
{
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_struct("graph-tool printer")
            .field("graph", &self.graph)
            .finish()
    }
}
